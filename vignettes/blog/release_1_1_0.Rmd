---
title: "Release 1.1.0"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{release_1_1_0}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r cran-setup, include = FALSE, message=FALSE, warning=FALSE}
NOT_CRAN <- identical(tolower(Sys.getenv("NOT_CRAN")), "true")
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  purl = NOT_CRAN
)
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(
	eval = TRUE,
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
library(pipr)
library(ggplot2)
library(tidyverse)
library(knitr)
library(DT)
```


The World Bank's Poverty and Inequality Portal (PIP) houses the world's most comprehensive database on global poverty and inequality statistics. These data is now directly accessible in R through our new package: `{pipr}`. This package allows the user to easily query the [PIP API](https://pip.worldbank.org/api) from R.

`{pipr}` can be installed from CRAN with:

```{r installation, eval=FALSE}
install.packages("pipr")
```

## The Data Landscape: What's Available?

PIP data encompasses poverty and inequality measures for over 160 economies worldwide, based on household surveys dating back to 1981. This data powers critical global monitoring efforts like tracking progress toward the World Bank's goal of ending extreme poverty and the United Nations' Sustainable Development Goals.

Through `{pipr}`, you can access:

- **Poverty and Inequality Estimates** at various (and/or custom) poverty lines.
- **Country, regional and global level data** for each of the available indicators.
- **Grouped data tools** using the official World Bank methodology for your own data.
- **Country-specific profiles** with additional indicators (e.g. Multidimensional poverty, above and below 40th percentile).
- **Auxiliary economic data** like PPP conversion factors, GDP, and CPI values.

## Poverty and Inequality Estimates

The main function `get_stats()` allows you to query poverty and inequality statistics. The user can specify the country, year, poverty line, and other parameters to retrieve the desired data. Here's an example for Nigeria with the default poverty line, 2.15\$ at 2017 PPPs:

```{r poverty_data}
nga_data <- get_stats(country = "NGA", year = 2018) |>
  select(country_name, year, poverty_line, headcount, poverty_gap, poverty_severity, watts)

nga_data
```
However, `get_stats()` can be used to retrieve data for multiple poverty line as well, creating many analytical opportunities. For instance:

```{r ipls_sensitivity_data}
ipls <- seq(from = 2, to = 10, length.out = 10)

ipls_sensitivity_data <- purrr::map(.x = ipls,
                                    .f = ~ get_stats(country = 'NGA',
                                                     year = 2018,
                                                     povline = .x)) |>
  bind_rows() |>
  select(year, poverty_line, headcount, poverty_gap, mean, median)
```

Which allows the user to analyze how poverty metrics change with different poverty lines:

```{r ipls_sensitivity_viz, echo=FALSE, fig.height=6, fig.width=10}
graph_data <- ipls_sensitivity_data |>
  pivot_longer(cols = c(headcount, poverty_gap),
               names_to = "Measure",
               values_to = "Value") |>
  mutate(
    # Convert proportions to percentages
    Value = Value * 100,
    Measure = recode(Measure,
                     "headcount" = "Headcount (%)",
                     "poverty_gap" = "Poverty Gap (%)")
  )

# Get maximum y-value (for annotation placement)
max_y <- max(graph_data$Value, na.rm = TRUE)

graph <- ggplot(graph1_data, aes(x = poverty_line, y = Value, color = Measure)) +
  geom_line(size = 1) +
  geom_vline(xintercept = country_data$median, linetype = "dashed", color = "gray40") +
  geom_vline(xintercept = country_data$mean, linetype = "dashed", color = "gray60") +
  annotate("text",
           x = country_data$median,
           y = max_y1,
           label = paste("Median =", round(country_data$median, 2)),
           angle = 90, vjust = -0.5, hjust = 1, size = 3) +
  annotate("text",
           x = country_data$mean,
           y = max_y1,
           label = paste("Mean =", round(country_data$mean, 2)),
           angle = 90, vjust = -0.5, hjust = 1, size = 3) +
  scale_color_brewer(palette = "Dark2") +
  labs(
    title = paste("Poverty Sensitivity Analysis for", country_chosen),
    subtitle = paste("Year:", country_data$year),
    x = "Poverty Line($/day)",
    y = "",
    color = ""
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1)) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
    plot.subtitle = element_text(size = 14, hjust = 0.5),
    axis.title = element_text(face = "bold")
  )

graph
```

`get_stats()` also returns inequality metrics (e.g. Gini coefficient) which can be seamlessly integrated into your analysis:

```{r inequality_data}
df_gini <- get_stats() |>
  filter((year == 2019 | year == 2020) & reporting_level == "national") |> # Select years and national data
  group_by(country_code, welfare_type, comparable_spell) |> # Group by country and welfare type
  filter(n() == 2) |> # Keep only countries with data in both years
  arrange(country_code, year) |> # Ensure sorted order
  mutate(ginichange = gini - lag(gini),
         country_code_chr = as.character(country_code)) |> # Calculate change in Gini
  filter(year == 2020) |> # Keep only 2020 data for plotting
  group_by(country_code, region_name) |> # Find mean for countries with two survey sources
  summarize(ginichange = mean(ginichange, na.rm = TRUE))
```


```{r inequality_viz, echo=FALSE, fig.height=6, fig.width=10}
gini_plot <- ggplot(df_gini,
                    aes(x = reorder(country_code, ginichange),
                        y = ginichange * 100, fill = region_name)) +
  geom_bar(stat = "identity") +
  labs(
    title = "Change in Gini Index (2019â€“2020)",
    subtitle = "Change in inequality (Gini points) for countries with comparable data",
    x = "Country",
    y = "Change in Gini Points"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
  )+
  # remove legend title
  guides(fill = guide_legend(title = NULL))


gini_plot
```

And you can also explore how poverty is distributed across different deciles of the population:

```{r deciles_data}
country_chosen <- c("BRA", "PER") 
# Brazil (a large reduction in Gini, less inequality), 
# and Peru (a large increase in Gini, more inequality)

deciles <- get_stats() |>
  filter(country_code %in% country_chosen) |>
  select(country_code, year, poverty_line, contains('decile'))

deciles_long <- deciles |>
  filter(year %in% c(2019, 2020)) |>
  group_by(country_code, year)|>
  tidyr::pivot_longer(cols = contains('decile'), names_to = "decile",
                      values_to = "welfare_share") |>
  mutate(decile = as.numeric(stringr::str_remove(decile, "decile")))|>
  mutate(cum_share = cumsum(welfare_share))

deciles_long <- bind_rows(deciles_long,
                          tidyr::expand_grid(country_code = unique(deciles_long$country_code),
                                      year = unique(deciles_long$year),
                                      decile = 0, welfare_share = 0, cum_share = 0))
```

Having access to welfare shares deciles allows the user to simulate a Lorenz curve analysis:
```{r deciles_viz, echo=FALSE, fig.height=6, fig.width=10}
library(scales)
ggplot(deciles_long, aes(x = decile, y = cum_share,
                         group = as.factor(year), colour = as.factor(year))) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  geom_abline(slope = 1/10, intercept = 0, linetype = "dashed", color = "gray50") +
  scale_color_brewer(palette = "Dark2", name = "Year") +
  labs(
    title = paste("Cumulative Welfare Shares for", paste(country_chosen, collapse = " and ")),
    subtitle = "Comparison across years",
    x = "Income Decile",
    y = "Cumulative Welfare Share (%)"
  ) +
  scale_y_continuous(labels = percent_format(scale = 1)) +
  facet_wrap(~ country_code) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
    plot.subtitle = element_text(size = 14, hjust = 0.5),
    axis.title = element_text(face = "bold")
  )
```

## Regional and World level data

`get_wb()` on the other hand, allows the user to access pre-aggregated data for global and regional aggregates. `get_regions()` can be used to retrieve a list of available regions:

```{r regional_data_1}
regions <- get_regions() 
regions |>
  DT::datatable(options = list(scrollX = TRUE))
```

Notice that if we include Eastern and Southern Africa (AFE) and Western Africa (AFW) regions, we would double-count the number of poor. To retrieve the data, we can use `get_wb()` and filter out the unwanted regions:

```{r regional_data_2}
regions <- get_wb() |>
  filter(year > 1995 & year < 2024) |>
  filter(!region_code %in% c("WLD", "AFE", "AFW")) |>
  mutate(
    pop_in_poverty = round(pop_in_poverty / 1000000, 0),
    headcount = round(headcount, 3)) |>
  select(region_name, year, pop_in_poverty, headcount)

regions |>
  DT::datatable(options = list(scrollX = TRUE))
```


```{r regional_viz, fig.width=10, fig.height=6}
ggplot(regions, aes(y = pop_in_poverty, x = year, fill = region_name)) +
  geom_area() +
  scale_y_continuous(
    limits = c(0, 2000),
    breaks = c(0, 500, 1000, 1500, 2000)
  ) +
  scale_fill_tableau(palette = "Tableau 10") +
  labs(
    y = "Number of poor (million)",
    x = ""
  ) +
  theme_classic() +
  theme(
    legend.position = "bottom"
  ) +
  guides(fill = guide_legend(title = ""))

```

## Group data tools

The `{pipr}` package also allows the user to apply the official group data methodology to their own data. This can be done using the `get_gd()` function. Here's an example using the Datt dataset:

```{r lorenz_data}
lorenz_points_lq <- get_gd(datt_rural$L, datt_rural$p, estimate = "lorenz", lorenz = "lq")
lorenz_points_lq_10 <- get_gd(datt_rural$L, datt_rural$p, estimate = "lorenz", lorenz = "lq", n_bins = 10)
```

```{r lorenz_viz, fig.width=10, fig.height=6}
ggplot() +
  geom_bar(data = lorenz_points_lq_10, aes(x = weight, y = welfare), stat = "identity", fill = "darkorange", alpha = 0.3) +
  geom_point(data = datt_rural, aes(x = p, y = L), color = "darkorange", size = 2) +
  geom_point(data = lorenz_points_lq, aes(x = weight, y = welfare), color = "darkorange", size = 0.5) +
  geom_abline(intercept = 0, slope = 1, color = "black") +
  labs(
    title = "Lorenz Curve for Rural India, 1983",
    x = "Cumulative Share of Population",
    y = "Cumulative Share of Welfare"
  ) +
  theme_minimal()
```


## Conclusion

The `{pipr}` package transforms how researchers, policy analysts, and data scientists can work with global poverty and inequality data, and it has many notable features... 

- **Direct Access**: Query the World Bank's authoritative poverty database directly from R.
- **Rich Context**: Access not just headline statistics but the full range of supporting data.
- **Comparative Analysis**: Easily compare poverty and inequality across countries, regions, and time periods.
- **Reproducibility**: Access previous versions of the PIP database for reproducible research.
- **Efficiency through caching**: Automatically cache API responses to speed up subsequent queries.

