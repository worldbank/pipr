---
title: "Release 1.1.0"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{release_1_1_0}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r cran-setup, include = FALSE, message=FALSE, warning=FALSE}
NOT_CRAN <- identical(tolower(Sys.getenv("NOT_CRAN")), "true")
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  purl = NOT_CRAN
)
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(
	eval = TRUE,
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
library(pipr)
library(ggplot2)
library(tidyverse)
library(knitr)
library(DT)
library(scales)
```

```{r wb_palette_setup, include=FALSE}
wb_colors <- list(
  blue = "#0071BC",
  orange = "#F7941D",
  green = "#6CBE45",
  red = "#D12229",
  purple = "#662D91",
  yellow = "#FFC426",
  darkblue = "#00205B"
)

theme_wb <- function(base_size = 14) {
  theme_minimal(base_size = base_size) +
  theme(
    plot.title = element_text(face = "bold", size = base_size + 2, hjust = 0.5),
    plot.subtitle = element_text(size = base_size, hjust = 0.5, margin = margin(b = 10)),
    axis.title = element_text(face = "bold"),
    legend.position = "bottom",
    legend.title = element_blank(),
    panel.grid.minor = element_blank()
  )
}
```

## Introducing pipr: The R Interface to Global Poverty Data

We're excited to announce that `{pipr}` is now available on CRAN! The World Bank's Poverty and Inequality Portal (PIP) hosts the world's most comprehensive database on global poverty and inequality statistics. `{pipr}` allows the user to easily query the [PIP API](https://pip.worldbank.org/api) from R. With this package, R users can seamlessly integrate these statistics into their research and analysis workflows.

`{pipr}` can be installed from CRAN with:

```{r installation, eval=FALSE}
install.packages("pipr")
```

## The Data Landscape: What's Available?

PIP data encompasses poverty and inequality measures for over 160 economies worldwide, based on household surveys dating back to 1981. These data powers critical global monitoring efforts - tracking progress toward the World Bank's goal of ending extreme poverty and the United Nations' Sustainable Development Goals.

Through `{pipr}`, you can access:

- **Poverty and Inequality Estimates** at various (or custom) poverty lines.
- **Regional and global level data** for each of the available indicators.
- **Grouped data tools** applying the official World Bank methodology.
- **Country-specific profiles** with additional indicators (e.g. Multidimensional poverty indicators).
- **Auxiliary economic data** like PPP conversion factors, GDP, and CPI values.


## Poverty and Inequality Estimates


The main function `get_stats()` allows you to query poverty and inequality statistics. The user can specify the country, year, poverty line, and other parameters to retrieve the desired data. Here's an example for Nigeria using the default poverty line, 2.15\$ at 2017 PPPs:

```{r poverty_data}
nga_data <- get_stats(country = "NGA", 
                      year = 2018) |> 
  # Here we select only some indicators, find the full list with: get_aux("dictionary")
  select(country_name, year, poverty_line, headcount, poverty_gap, 
         poverty_severity, watts)

nga_data
```

Beyond retrieving a single snapshot, `get_stats()` lets you explore how poverty measures change when varying the poverty line. In the example below, data are gathered for Nigeria over a range of poverty lines (from \$2 to \$10 per day),  which includes key thresholds such as the default IPL (\$2.15), the lower-middle income IPL (\$3.65), and the higher-middle income IPL (\$6.85). This capability is ideal for sensitivity analyses:

```{r ipls_sensitivity_data}

# A range of hypothetical international poverty lines (10)
# which includes the default IPL (2.15), the lower middle income ipl(3.65)
# and the higher middle income ipl (6.85)
ipls <- seq(from = 2, to = 10, length.out = 10)

# pipr allows you to loop through the ipls and query the API for each ipl using purrr::map()
ipls_sensitivity_data <- purrr::map(.x = ipls,
                                    .f = ~ get_stats(country = 'NGA',
                                                     year = 2018,
                                                     povline = .x)) |>
  bind_rows() |>
  select(year, poverty_line, headcount, poverty_gap, mean, median)

ipls_sensitivity_data |>
  select(poverty_line, headcount, poverty_gap) |>
  mutate(across(c(headcount, poverty_gap), ~ round(.x, 3))) |>
  DT::datatable(options = list(scrollX = TRUE))
```

These data can be visualized to illustrate how poverty measures respond to changes in the poverty line. The following graph displays the poverty headcount and poverty gap indicators, along with reference lines for Nigeria’s mean and median poverty lines:

```{r ipls_sensitivity_viz, echo=FALSE}
graph_data <- ipls_sensitivity_data |>
  pivot_longer(cols = c(headcount, poverty_gap),
               names_to = "Measure",
               values_to = "Value") |>
  mutate(
    # Convert proportions to percentages
    Value = Value * 100,
    Measure = recode(Measure,
                     "headcount" = "Headcount (%)",
                     "poverty_gap" = "Poverty Gap (%)")
  )

# Get maximum y-value (for annotation placement)
max_y <- max(graph_data$Value, na.rm = TRUE)

graph <- ggplot(graph_data, aes(x = poverty_line, y = Value, color = Measure)) +
  geom_line(linewidth = 1) +
  geom_vline(xintercept = ipls_sensitivity_data$median[1], linetype = "dashed", color = "gray40") +
  geom_vline(xintercept = ipls_sensitivity_data$mean[1], linetype = "dashed", color = "gray60") +
  annotate("text",
           x = ipls_sensitivity_data$median[1],
           y = max_y * 0.9,
           label = paste("Median =", round(ipls_sensitivity_data$median[1], 2)),
           angle = 90, vjust = -0.5, hjust = 1, size = 3) +
  annotate("text",
           x = ipls_sensitivity_data$mean[1],
           y = max_y * 0.9,
           label = paste("Mean =", round(ipls_sensitivity_data$mean[1], 2)),
           angle = 90, vjust = -0.5, hjust = 1, size = 3) +
  scale_color_manual(values = c("Headcount (%)" = wb_colors$blue, 
                                "Poverty Gap (%)" = wb_colors$orange)) +
  labs(
    title = "Poverty Sensitivity Analysis for Nigeria",
    subtitle = paste("Year:", ipls_sensitivity_data$year[1]),
    x = "Poverty Line ($/day)",
    y = ""
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1)) +
  theme_wb()

graph
```

In addition to poverty measures, `get_stats()` returns inequality metrics (e.g. Gini coefficient), and can be used for comparative analysis. Here's an example comparing the change in Gini index between 2019 and 2020 for countries with comparable data:

```{r inequality_data}
df_gini <- get_stats() |>
  filter((year == 2019 | year == 2020) & reporting_level == "national") |> 
  group_by(country_code, welfare_type, comparable_spell) |> 
  filter(n() == 2) |> # Keep only countries with data in both years
  arrange(country_code, year) |> # Ensure sorted order
  mutate(ginichange = gini - lag(gini)) |> # Calculate change in Gini
  filter(year == 2020) |>
  group_by(country_code, region_name) |> # Find mean for countries with two survey sources
  summarize(ginichange = mean(ginichange, na.rm = TRUE))
```

From extracting the data with `{pipr}` to cleaning and preparing them, it can all be done in one pipeline, as shown above. The data can then be visualized to compare the change in inequality across countries:

```{r inequality_viz, echo=FALSE}
gini_plot <- ggplot(df_gini,
                    aes(x = reorder(country_code, ginichange),
                        y = ginichange * 100, fill = region_name)) +
  geom_bar(stat = "identity") +
  labs(
    title = "Change in Gini Index (2019–2020)",
    subtitle = "Change in inequality (Gini points) for countries with comparable data",
    x = "Country",
    y = "Change in Gini Points"
  ) +
  scale_fill_manual(values = c(
    "Sub-Saharan Africa" = wb_colors$yellow,
    "East Asia & Pacific" = wb_colors$red,
    "Europe & Central Asia" = wb_colors$orange,
    "Latin America & Caribbean" = wb_colors$green,
    "Middle East & North Africa" = wb_colors$purple,
    "Other High Income Countries" = wb_colors$blue
  )) +
  theme_wb() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
  
gini_plot
```

Furthermore, `get_stats()` provides indicators suitable for more advanced distributional analyses. For instance, the following code retrieves income decile and welfare share data for Brazil and Peru—countries that have experienced contrasting inequality trends between 2019 and 2020:

```{r deciles_data}
country_chosen <- c("BRA", "PER") 
# Brazil (a large reduction in Gini, less inequality), 
# and Peru (a large increase in Gini, more inequality)

deciles <- get_stats() |>
  filter(country_code %in% country_chosen) |>
  select(country_code, year, poverty_line, contains('decile'))

deciles_long <- deciles |>
  filter(year %in% c(2019, 2020)) |>
  group_by(country_code, year)|>
  tidyr::pivot_longer(cols = contains('decile'), names_to = "decile",
                      values_to = "welfare_share") |>
  mutate(decile = as.numeric(stringr::str_remove(decile, "decile")))|>
  mutate(cum_share = cumsum(welfare_share))

deciles_long <- bind_rows(deciles_long,
                          tidyr::expand_grid(country_code = unique(deciles_long$country_code),
                                      year = unique(deciles_long$year),
                                      decile = 0, welfare_share = 0, cum_share = 0))
```

Having access to welfare shares and income deciles allows the user to simulate a Lorenz curve analysis, as seen in the graph below:

```{r deciles_viz, echo=FALSE}
ggplot(deciles_long, aes(x = decile, y = cum_share,
                         group = as.factor(year), colour = as.factor(year))) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  geom_abline(slope = 1/10, intercept = 0, linetype = "dashed", color = "gray50") +
  scale_color_manual(
    values = c("2019" = wb_colors$blue, "2020" = wb_colors$orange),
    name = "Year"
  ) +
  labs(
    title = paste("Cumulative Welfare Shares for", paste(country_chosen, collapse = " and ")),
    subtitle = "Comparison across years",
    x = "Income Decile",
    y = "Cumulative Welfare Share (%)"
  ) +
  scale_y_continuous(labels = percent_format(scale = 100)) +
  facet_wrap(~ country_code) +
  theme_wb()

```


## Regional and World level data

While country-level analyses offer valuable insights, understanding global and regional trends is essential for putting individual country performance into context and recognizing broader patterns. The `{pipr}` package makes it just as easy to access these aggregated statistics.

The function `get_wb()` allows the user to access pre-aggregated regional and global data. `get_regions()` can be used to retrieve a list of the regions and their respective region codes:

```{r regional_data_1}
regions <- pipr:::get_regions() 
regions |>
  DT::datatable(options = list(scrollX = TRUE))
```

Notice that if we include Eastern and Southern Africa (AFE) and Western Africa (AFW) together with Sub-Saharan Africa (SSA), we would double-count the number of poor. To retrieve the data, we can use `get_wb()` and filter out the unwanted regions:

```{r regional_data_2}
regions <- get_wb() |>
  filter(year > 1995 & year < 2024) |>
  filter(!region_code %in% c("WLD", "AFE", "AFW")) |>
  mutate(
    pop_in_poverty = round(pop_in_poverty / 1000000, 0),
    headcount = round(headcount, 3)) |>
  select(region_name, year, pop_in_poverty, headcount)

regions |>
  DT::datatable(options = list(scrollX = TRUE))
```

Having access to additional variables, such as the total population in poverty, allows for more advanced visualizations. Here's an example of the number of poor people (in millions) in each region over time:

```{r regional_viz}
ggplot(regions, aes(y = pop_in_poverty, x = year, fill = region_name)) +
  geom_area(alpha = 0.85) +
  scale_y_continuous(
    limits = c(0, 2000),
    breaks = c(0, 500, 1000, 1500, 2000)
  ) +
  scale_fill_manual(
    values = c(
    "Sub-Saharan Africa" = wb_colors$yellow,
    "East Asia & Pacific" = wb_colors$red,
    "Europe & Central Asia" = wb_colors$orange,
    "Latin America & Caribbean" = wb_colors$green,
    "Middle East & North Africa" = wb_colors$purple,
    "Other High Income Countries" = wb_colors$blue,
    "South Asia" = wb_colors$darkblue
    ),
    name = ""
  ) +
  labs(
    y = "Number of poor (million)",
    x = ""
  ) +
  theme_wb()
```

## Grouped data tools

The `{pipr}` package also allows the user to apply the official [World Bank grouped data methodology](https://datanalytics.worldbank.org/PIP-Methodology/welfareaggregate.html#tgd) to their own data. This can be done using the `get_gd()` function. Here's an example using historical data from [Datt(1998)](https://ageconsearch.umn.edu/record/94862/?ln=en&v=pdf) for rural India in 1983:

```{r datt_data}
datt_rural |>
  select(monthly_pc_exp, p, L) |>
  mutate(across(c(p, L), ~ round(.x, 2)) ) |>
  DT::datatable(options = list(scrollX = TRUE))
```

As you can see from the table above, the data is grouped by monthly per capita expenditure, with cumulative welfare share (`L`) and cumulative percentage of individuals(`p`) for each group. The `get_gd()` function can be used to estimate poverty metrics from this type of grouped data:

```{r grouped_poverty}
get_gd(datt_rural$L, 
       datt_rural$p,
       requested_mean = 109.9,
       povline = 89) |>
  # round all numeric variables (where is numeric)
  mutate(across(where(is.numeric), ~ round(.x, 2))) |>
  DT::datatable(options = list(scrollX = TRUE))
```
`get_gd()` can also be used to estimate Lorenz curves:

```{r grouped_lorenz_data}
lorenz_points_lq <- get_gd(datt_rural$L, # Cumulative population
                           datt_rural$p, # Cumulative welfare
                           estimate = "lorenz", 
                           lorenz = "lq") # Type of Lorenz curve methodology
```

In this visualization, in red you can see the original data points from Datt (1998), and in orange the Lorenz curve points estimated by `{pipr}`:

```{r lorenz_viz}
ggplot() +
  geom_point(data = datt_rural, 
             aes(x = p, y = L), 
             color = wb_colors$red, 
             size = 3) +
  geom_point(data = lorenz_points_lq, 
             aes(x = weight, y = welfare), 
             color = wb_colors$orange, 
             size = 1) +
  geom_abline(intercept = 0, slope = 1, color = "black") +
  labs(
    title = "Lorenz Curve for Rural India, 1983",
    x = "Cumulative Share of Population",
    y = "Cumulative Share of Welfare"
  ) +
  theme_wb()
```


## Reproducible data and methods

`{pipr}` not only provides the latest data from PIP but also lets users query specific data versions and tracks changes in the underlying R code:

- **Data Versioning**: By default, the API returns the most recent data, but it is possible to list other available versions too using `get_versions()`. Then, a specific version can then be selected and passed it to `{pipr}` functions:

```{r data_versions}
data_versions <- get_versions()
get_stats(country = "AGO", version = data_versions$version[2])
```


- **Code Versioning**: Methodological changes can affect reproducibility even with unchanged data. The function `get_pip_info()` retrieves version information for the key R packages powering PIP—[{pipapi}](https://github.com/PIP-Technical-Team/pipapi) and [{wbpip}](https://github.com/PIP-Technical-Team/wbpip)— as well as details on the R version and operating system:


```{r code_versions}
pip_info <- get_pip_info()
pip_info$pip_packages
```

## Performance Through Smart Caching

A key feature of `pipr` is its caching system that improves performance for repeated queries:

```{r caching}
# First API call (slower)
system.time(get_stats(country = "CHN", year = 2018))

# Second call using cache (much faster)
system.time(get_stats(country = "CHN", year = 2018))
```

Results are cached locally for 2 hours, making subsequent identical queries significantly faster.
This is particularly useful when iteratively developing analyses or working with limited internet connectivity.



## Conclusion

The `{pipr}` package transforms how researchers, policy analysts, and data scientists can work with global poverty and inequality data. 
Key features include:

- **Direct API Access**: Query the World Bank's poverty database directly from R.
- **Rich Context**: Access not just headline statistics but the full range of supporting data.
- **Comparative Analysis**: Easily compare poverty and inequality across countries, regions, and time periods.
- **Reproducibility**: Access previous versions of the PIP database for fully reproducible research.
- **Efficient Workflows**: Automatically cache API responses to speed up subsequent queries.

Whether you're conducting academic research, developing policy recommendations, or creating data visualizations for advocacy, `{pipr}` provides the tools you need to incorporate global poverty data into your R workflow seamlessly.


